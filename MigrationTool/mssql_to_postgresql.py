from .constants import ENGINES_CONVERSION
from .helpers import validate_sql_statement
from sqlalchemy.engine.result import ResultProxy
import pandas as pd


def create_tables(table_names, insp_mssql, eng_postgresql):
    # Create the tables without the data.
    for table in table_names:
        print(f'Attempting to create {table}...')
        print(insp_mssql.get_pk_constraint(table))
        query = get_create_sql(insp_mssql.get_columns(table), table, eng_postgresql,
                               insp_mssql.get_pk_constraint(table)['constrained_columns'])
        result = eng_postgresql.execute(query)
        if type(result) is ResultProxy:
            print(f'Table {table} successfully created.')
        print("<===============================================>")


def migrate_data_to_postgres(table_names_mssql, eng_mssql, eng_postgresql):
    # Pass data to the tables
    for table in table_names_mssql:
        print(f'Attempting to migrate data on {table}')
        with eng_mssql.connect() as con:
            result = con.execute(f'SELECT * FROM "{table}"')
            df = pd.DataFrame(result.fetchall(), columns=result.keys())
            print(df.head())
            df.to_sql(table, con=eng_postgresql, if_exists='append', index=False)


def migrate_constraints(table_names_mssql, insp_mssql, insp_postgresql, eng_postgresql):
    # Add the foreign keys to the tables.
    for table in table_names_mssql:
        print(f'Finding foreign Keys...')
        if len(insp_mssql.get_foreign_keys(table)) != 0:
            if len(insp_postgresql.get_foreign_keys(table)) == 0:
                print(f'Foreign key founded on table {table}')
                print(f'Attempting to create the foreign key...')
                print(f'{table} ====> {insp_mssql.get_foreign_keys(table)}')
                eng_postgresql.execute(create_foreign_key_statement(table, insp_mssql.get_foreign_keys(table)))
                print("<===============================================>")


def get_create_sql(table_info, table_name, target_engine, constrained_columns=[]):
    create_table_statement = f'CREATE TABLE "{table_name}" ('
    for field in table_info:
        create_table_statement += generate_field_statement(field, 'mssql_postgresql', target_engine)

    if len(constrained_columns) == 1:
        create_table_statement += f'PRIMARY KEY ("{constrained_columns[0]}")'
    elif len(constrained_columns) > 1:
        constrains = ""
        for constrain in constrained_columns:
            constrains += f'"{constrain}"' + ','
        create_table_statement += f'PRIMARY KEY ({constrains[:-1]})'
    return validate_sql_statement(create_table_statement + ')')


def clean_type(object_type, target='mssql_postgresql'):
    """
    :param object_type: this is the type that we want to transform (i.e: NVARCHAR to varchar)
    :param target: this is the database that we want to migrate to (i.e: from mssql to postgresql)
    :return: the return will be the type of data that the target_db supports (i.e: postgresql varchar)
    """
    return get_clean_type(object_type, target)


# TODO: evaluate the parameters of the method, need to evaluate if the target_db is X or Y.
#   Right now it is only working with postgresql
def generate_field_statement(field, target_db, db_connection):
    """
    :param field: The field we are going to generate and pass to the creation table statement
    (i.e: NAME int GENERATED ALWAYS AS IDENTITY...)
    :param target_db: The target db where we are going to pass the table on the actual_db
    :param db_connection: This is the Sql alchemy engine that we are using to create the sequences.
    :return: The string statement for the field
    """
    dtype = get_clean_type(field['type'], target_db)
    field_statement = f'"{field["name"]}" {dtype}'
    if field['autoincrement']:
        if field['sequence']['start'] == 1:
            field_statement += " GENERATED BY DEFAULT AS IDENTITY"
        else:
            db_connection.execute(f"CREATE SEQUENCE {field['sequence']['name']} start {field['sequence']['start']} "
                                  f"increment {field['sequence']['increment']}")
            field_statement += f" DEFAULT NEXTVAL({field['sequence']['name']})"
    if not field['nullable']:
        field_statement += " NOT NULL"
    if field['default'] is not None:
        if field['default'] == 'suser_sname()':
            field_statement += f" DEFAULT session_user"
        else:
            if dtype == 'bit':
                field_statement += f" DEFAULT {'0::bit' if field['default'] == '(0)' else '1::bit' }"
    return field_statement + ','


def get_clean_type(object_type, target):
    for engines in ENGINES_CONVERSION:
        if target in engines:
            eng = engines[target]

            # TODO: Rename variable parenthesis to something meaningful
            """ The parenthesis variable finds whether an object_type has a parenthesis in it.
                i.e NVARCHAR(15), being NVARCHAR the type we want to take into account
            """
            parenthesis = str(object_type).find('(')
            if parenthesis != -1:
                parenthesis_end = str(object_type).find(')')

                if str(object_type)[:parenthesis] == 'NTEXT' or str(object_type)[:parenthesis] == 'TEXT':
                    return eng[str(object_type)[:parenthesis]]

                if str(object_type)[:parenthesis] == 'BINARY' or str(object_type)[:parenthesis] == 'VARBINARY':
                    return eng[str(object_type)[:parenthesis]]

                return eng[str(object_type)[:parenthesis]] + str(object_type)[parenthesis:parenthesis_end+1]
            else:
                return eng[str(object_type)]
        else:
            print("This is awkward, this database engine is not supported yet. Sorry for the inconvenience")


def create_foreign_key_statement(table_name, table_keys):
    """
    This method will return the statement to add the new foreign key to the already migrated tables.
    :param table_name: This is where we are adding the constraints.
    :param table_keys: this are the constraints that the actual mssql table has.
    :return:
    """
    alter_table_query = f'ALTER TABLE "{table_name}" '
    constrains = ""
    for constrain in table_keys:
        constrained_columns = ','.join('"{0}"'.format(c) for c in constrain["constrained_columns"])
        referred_columns = ','.join('"{0}"'.format(c) for c in constrain["referred_columns"])
        constrains += f'ADD CONSTRAINT "{constrain["name"]}" FOREIGN KEY ({constrained_columns}) ' \
            f'REFERENCES "{constrain["referred_table"]}" ({referred_columns}) ,'
    return (alter_table_query + constrains)[:-1]
